<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Nexus</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0d0d12;
            --bg-mid: #151520;
            --bg-light: #1e1e2e;
            --accent: #b4a0d4;
            --accent-hover: #c9b8e6;
            --text: #e4e0ed;
            --text-dim: #9690a8;
            --text-muted: #5c5872;
            --border: #3d3658;
            --success: #8bc4a8;
            --error: #d4a0a0;
        }

        body {
            font-family: Georgia, 'Times New Roman', serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-mid) 100%);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header - Floating Menu Bar */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: var(--bg-mid);
            padding: 8px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .header.scrolled {
            padding: 6px 12px;
            background: rgba(21, 21, 32, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.4);
        }

        .header.scrolled h1 {
            font-size: 1em;
        }

        .header.scrolled .header-btn {
            padding: 4px 10px;
            font-size: 0.8em;
        }

        .header h1 {
            color: var(--accent);
            font-size: 1.2em;
            font-weight: normal;
            transition: font-size 0.3s ease;
            white-space: nowrap;
        }

        .header-buttons {
            display: flex;
            gap: 6px;
        }

        .header-btn {
            background: var(--bg-light);
            color: var(--text-dim);
            border: 1px solid var(--border);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: var(--border);
            color: var(--text);
        }

        /* Spacer to prevent content from hiding under fixed header */
        .header-spacer {
            height: 52px;
            flex-shrink: 0;
        }

        /* Chat Area */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.6;
            font-size: 1em;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .message.user {
            background: var(--bg-light);
            align-self: flex-end;
            border: 1px solid var(--border);
        }

        .message.assistant {
            background: var(--bg-mid);
            align-self: flex-start;
            border: 1px solid var(--border);
        }

        .message-role {
            font-size: 0.75em;
            font-weight: bold;
            margin-bottom: 6px;
            font-family: system-ui, sans-serif;
        }

        .message.user .message-role {
            color: var(--text-dim);
        }

        .message.assistant .message-role {
            color: var(--accent);
        }

        .message-content {
            color: var(--text);
        }

        /* Welcome */
        .welcome {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-dim);
        }

        .welcome h2 {
            color: var(--accent);
            font-size: 1.8em;
            margin-bottom: 16px;
            font-weight: normal;
        }

        /* Input Area */
        .input-area {
            background: var(--bg-mid);
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            flex-shrink: 0;
        }

        .input-container {
            display: flex;
            gap: 10px;
            max-width: 900px;
            margin: 0 auto;
        }

        .input-wrapper {
            flex: 1;
            position: relative;
        }

        #message-input {
            width: 100%;
            background: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 12px 16px;
            border-radius: 12px;
            font-family: Georgia, serif;
            font-size: 1em;
            resize: none;
            min-height: 48px;
            max-height: 150px;
            line-height: 1.5;
        }

        #message-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        #message-input::placeholder {
            color: var(--text-muted);
        }

        #send-btn {
            background: var(--accent);
            color: var(--bg-dark);
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.2s;
            align-self: flex-end;
        }

        #send-btn:hover {
            background: var(--accent-hover);
        }

        #send-btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }

        /* Status */
        .status {
            text-align: center;
            font-size: 0.8em;
            color: var(--text-muted);
            margin-top: 8px;
            font-family: system-ui, sans-serif;
        }

        .status.error {
            color: var(--error);
        }

        .status.success {
            color: var(--success);
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-mid);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h3 {
            color: var(--accent);
            margin-bottom: 16px;
            font-weight: normal;
        }

        .modal label {
            display: block;
            color: var(--text-dim);
            margin-bottom: 6px;
            font-size: 0.9em;
        }

        .modal input, .modal select {
            width: 100%;
            background: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 1em;
            margin-bottom: 16px;
        }

        .modal input:focus, .modal select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-btn {
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            border: none;
        }

        .modal-btn.primary {
            background: var(--accent);
            color: var(--bg-dark);
        }

        .modal-btn.secondary {
            background: var(--bg-light);
            color: var(--text);
            border: 1px solid var(--border);
        }

        /* Sessions list */
        .sessions-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 16px;
        }

        .session-item {
            padding: 10px 12px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-item:hover {
            border-color: var(--accent);
        }

        .session-item .name {
            color: var(--text);
        }

        .session-item .date {
            color: var(--text-muted);
            font-size: 0.8em;
        }

        .session-item .delete-btn {
            color: var(--error);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            font-size: 1.1em;
        }

        /* Loading animation */
        .typing-indicator {
            display: inline-block;
        }

        .typing-indicator span {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Mobile adjustments */
        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.1em;
            }

            .header-btn {
                padding: 6px 10px;
                font-size: 0.8em;
            }

            .message {
                max-width: 95%;
                font-size: 0.95em;
            }

            .chat-container {
                padding: 12px;
            }

            .input-area {
                padding: 12px;
            }

            #send-btn {
                padding: 12px 16px;
            }
        }
    </style>
</head>
<body>
    <div class="header" id="header">
        <h1>‚ú¶ The Nexus</h1>
        <div class="header-buttons">
            <button class="header-btn" onclick="showSettings()">‚öôÔ∏è</button>
            <button class="header-btn" onclick="showSessions()">üíæ</button>
            <button class="header-btn" onclick="showReferenceDocs()">üìö</button>
            <button class="header-btn" onclick="newSession()">‚ú¶</button>
        </div>
    </div>
    
    <div class="header-spacer"></div>

    <div class="chat-container" id="chat-container">
        <div class="welcome">
            <h2>The Nexus Awaits</h2>
            <p>Your framework is loaded and ready.<br>Type "Begin" to start a new session.</p>
        </div>
    </div>

    <div class="input-area">
        <div class="input-container">
            <div class="input-wrapper">
                <textarea id="message-input" placeholder="Enter your action..." rows="1"></textarea>
            </div>
            <button id="send-btn" onclick="sendMessage()">Send</button>
        </div>
        <div class="status" id="status">Ready</div>
    </div>

    <div class="modal-overlay" id="settings-modal">
        <div class="modal">
            <h3>Settings</h3>
            
            <label>Provider</label>
            <select id="provider-select" onchange="onProviderChange()">
                <option value="anthropic">Anthropic (Claude)</option>
                <option value="google">Google AI (Gemini)</option>
            </select>
            
            <div id="anthropic-key-section">
                <label>Anthropic API Key</label>
                <input type="password" id="api-key-input" placeholder="sk-ant-...">
            </div>
            
            <div id="google-key-section" style="display: none;">
                <label>Google AI Studio API Key</label>
                <input type="password" id="google-api-key-input" placeholder="AIza...">
            </div>
            
            <label>Model</label>
            <select id="model-select">
                <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5 (Balanced)</option>
                <option value="claude-opus-4-6">Claude Opus 4.6 (Best)</option>
                <option value="claude-opus-4-5">Claude Opus 4.5</option>
                <option value="claude-haiku-4-5-20251001">Claude Haiku 4.5 (Fast)</option>
            </select>
            
            <label>Temperature: <span id="temp-display">1.0</span></label>
            <input type="range" id="temp-slider" min="0" max="1.5" step="0.1" value="1.0" oninput="updateTempDisplay()">
            
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="closeSettings()">Cancel</button>
                <button class="modal-btn primary" onclick="saveSettings()">Save</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="sessions-modal">
        <div class="modal">
            <h3>Sessions</h3>
            <div class="sessions-list" id="sessions-list">
                <p style="color: var(--text-muted);">No saved sessions yet.</p>
            </div>
            
            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                <button class="modal-btn secondary" style="flex:1" onclick="loadFromFile()">üìÇ Open File</button>
                <button class="modal-btn secondary" style="flex:1" onclick="saveToFile()">üíæ Download</button>
            </div>
            
            <div style="margin-bottom: 16px;">
                <button class="modal-btn secondary" style="width: 100%; background: #2a2640;" onclick="archiveAndTrim()">üì¶ Archive & Trim</button>
                <p style="color: var(--text-muted); font-size: 11px; margin-top: 4px;">Save full archive, generate rolling summary, smart-trim to natural scene break</p>
            </div>
            
            <label>Session name:</label>
            <input type="text" id="session-name-input" placeholder="Session name...">
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="closeSessions()">Close</button>
                <button class="modal-btn primary" onclick="saveSession()">Save to Browser</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="reference-docs-modal">
        <div class="modal">
            <h3>üìö Reference Documents</h3>
            <p style="color: var(--text-dim); font-size: 0.9em; margin-bottom: 16px;">
                Upload playbooks, rules, maps, or other reference materials that The Nexus can use during your game.
            </p>
            
            <div class="reference-docs-list" id="reference-docs-list">
                <p style="color: var(--text-muted);">No reference documents uploaded.</p>
            </div>
            
            <div style="margin: 16px 0;">
                <input type="file" id="ref-doc-input" accept=".txt,.md,.pdf" style="display: none;" onchange="uploadReferenceDoc(event)">
                <button class="modal-btn secondary" style="width: 100%;" onclick="document.getElementById('ref-doc-input').click()">
                    + Upload Document (.txt, .md, .pdf)
                </button>
            </div>
            
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="closeReferenceDocs()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // NEXUS FRAMEWORK
        // ============================================================
        const NEXUS_FRAMEWORK = `
GENRE-FLEXIBLE IMMERSIVE RPG FRAMEWORK
Version 2.1 - Enhanced Edition with Prose Calibration Engine
Dynamic World States & Multi-Axis Intimacy

[... (Paste the full NEXUS_FRAMEWORK string from your original file here) ...]
`;

        // ============================================================
        // STATE
        // ============================================================
        let messages = [];
        let characterSheet = '';  // Portable character sheet from session
        let referenceDocuments = [];  // User-uploaded reference docs (playbooks, rules, etc.)
        let currentStoryName = localStorage.getItem('nexus_story_name') || '';  // Persisted story name
        let isGenerating = false;
        let abortController = null;

        // ============================================================
        // SETTINGS
        // ============================================================
        function getProvider() {
            return localStorage.getItem('nexus_provider') || 'anthropic';
        }
        
        function getApiKey() {
            return localStorage.getItem('nexus_api_key') || '';
        }
        
        function getGoogleApiKey() {
            return localStorage.getItem('nexus_google_api_key') || '';
        }

        function getModel() {
            return localStorage.getItem('nexus_model') || 'claude-sonnet-4-5-20250929';
        }

        function getTemperature() {
            return parseFloat(localStorage.getItem('nexus_temperature') || '1.0');
        }
        
        function onProviderChange() {
            const provider = document.getElementById('provider-select').value;
            const modelSelect = document.getElementById('model-select');
            const anthropicSection = document.getElementById('anthropic-key-section');
            const googleSection = document.getElementById('google-key-section');
            
            if (provider === 'anthropic') {
                anthropicSection.style.display = 'block';
                googleSection.style.display = 'none';
                modelSelect.innerHTML = `
                    <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5 (Balanced)</option>
                    <option value="claude-opus-4-6">Claude Opus 4.6 (Best)</option>
                    <option value="claude-opus-4-5">Claude Opus 4.5</option>
                    <option value="claude-haiku-4-5-20251001">Claude Haiku 4.5 (Fast)</option>
                `;
            } else if (provider === 'google') {
                anthropicSection.style.display = 'none';
                googleSection.style.display = 'block';
                modelSelect.innerHTML = `
                    <option value="gemini-3-pro-preview">Gemini 3 Pro Preview (Best)</option>
                    <option value="gemini-3-flash-preview">Gemini 3 Flash Preview (Fast)</option>
                    <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                    <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                    <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                `;
            }
        }

        function showSettings() {
            document.getElementById('provider-select').value = getProvider();
            document.getElementById('api-key-input').value = getApiKey();
            document.getElementById('google-api-key-input').value = getGoogleApiKey();
            document.getElementById('temp-slider').value = getTemperature();
            onProviderChange();  // Update UI based on provider
            document.getElementById('model-select').value = getModel();
            updateTempDisplay();
            document.getElementById('settings-modal').classList.add('active');
        }

        function closeSettings() {
            document.getElementById('settings-modal').classList.remove('active');
        }

        function saveSettings() {
            const provider = document.getElementById('provider-select').value;
            const apiKey = document.getElementById('api-key-input').value.trim();
            const googleApiKey = document.getElementById('google-api-key-input').value.trim();
            const model = document.getElementById('model-select').value;
            const temp = document.getElementById('temp-slider').value;
            
            localStorage.setItem('nexus_provider', provider);
            if (apiKey) {
                localStorage.setItem('nexus_api_key', apiKey);
            }
            if (googleApiKey) {
                localStorage.setItem('nexus_google_api_key', googleApiKey);
            }
            localStorage.setItem('nexus_model', model);
            localStorage.setItem('nexus_temperature', temp);
            
            closeSettings();
            setStatus('Settings saved', 'success');
        }

        function updateTempDisplay() {
            const val = document.getElementById('temp-slider').value;
            document.getElementById('temp-display').textContent = parseFloat(val).toFixed(1);
        }

        // ============================================================
        // SESSIONS
        // ============================================================
        function getSessions() {
            return JSON.parse(localStorage.getItem('nexus_sessions') || '{}');
        }

        function showSessions() {
            const sessions = getSessions();
            const list = document.getElementById('sessions-list');
            
            // Populate the session name input with current story name
            document.getElementById('session-name-input').value = currentStoryName || '';
            
            let html = '';
            
            // Local storage sessions
            if (Object.keys(sessions).length > 0) {
                html += '<div style="color: var(--text-muted); font-size: 0.85em; margin-bottom: 8px;">Browser Sessions:</div>';
                html += Object.entries(sessions)
                    .sort((a, b) => new Date(b[1].date) - new Date(a[1].date))
                    .map(([name, data]) => `
                        <div class="session-item" onclick="loadSession('${name}')">
                            <div>
                                <div class="name">${name}</div>
                                <div class="date">${new Date(data.date).toLocaleDateString()}</div>
                            </div>
                            <button class="delete-btn" onclick="event.stopPropagation(); deleteSession('${name}')">√ó</button>
                        </div>
                    `).join('');
            }
            
            if (!html) {
                html = '<p style="color: var(--text-muted);">No browser sessions yet.</p>';
            }
            
            list.innerHTML = html;
            document.getElementById('sessions-modal').classList.add('active');
        }

        function closeSessions() {
            document.getElementById('sessions-modal').classList.remove('active');
        }

        // ============================================================
        // REFERENCE DOCUMENTS
        // ============================================================
        function showReferenceDocs() {
            renderReferenceDocsList();
            document.getElementById('reference-docs-modal').classList.add('active');
        }

        function closeReferenceDocs() {
            document.getElementById('reference-docs-modal').classList.remove('active');
        }

        function renderReferenceDocsList() {
            const list = document.getElementById('reference-docs-list');
            
            if (referenceDocuments.length === 0) {
                list.innerHTML = '<p style="color: var(--text-muted);">No reference documents uploaded.</p>';
                return;
            }
            
            const html = referenceDocuments.map((doc, index) => `
                <div class="session-item" style="cursor: default;">
                    <div>
                        <div class="name">${doc.name}</div>
                        <div class="date">${(doc.content.length / 1024).toFixed(1)} KB</div>
                    </div>
                    <button class="delete-btn" onclick="deleteReferenceDoc(${index})">√ó</button>
                </div>
            `).join('');
            
            list.innerHTML = html;
        }

        async function uploadReferenceDoc(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            setStatus('Processing file...', '');
            
            try {
                let content = '';
                const fileName = file.name;
                
                if (file.name.endsWith('.pdf')) {
                    // Extract text from PDF using PDF.js
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        
                        setStatus(`Extracting text from ${pdf.numPages} pages...`, '');
                        
                        // Extract text from all pages
                        const textPromises = [];
                        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                            textPromises.push(
                                pdf.getPage(pageNum).then(async (page) => {
                                    const textContent = await page.getTextContent();
                                    const pageText = textContent.items
                                        .map(item => item.str)
                                        .join(' ');
                                    return `\n--- Page ${pageNum} ---\n${pageText}`;
                                })
                            );
                        }
                        
                        const pages = await Promise.all(textPromises);
                        content = pages.join('\n\n');
                        
                        if (!content.trim()) {
                            throw new Error('No text could be extracted from this PDF. It may be image-based or encrypted.');
                        }
                        
                    } catch (pdfErr) {
                        console.error('PDF extraction error:', pdfErr);
                        throw new Error(`PDF extraction failed: ${pdfErr.message}`);
                    }
                } else {
                    // Read as text for .txt and .md files
                    content = await file.text();
                }
                
                // Check if content is reasonable
                if (content.length > 500000) {
                    if (!confirm(`This file is ${(content.length / 1024).toFixed(1)} KB. Large files may slow down responses. Continue?`)) {
                        event.target.value = '';
                        setStatus('Upload cancelled', '');
                        return;
                    }
                }
                
                // Add to reference documents
                referenceDocuments.push({
                    name: fileName,
                    content: content,
                    uploadedAt: new Date().toISOString()
                });
                
                renderReferenceDocsList();
                setStatus(`Added: ${fileName} (${(content.length / 1024).toFixed(1)} KB)`, 'success');
                
                // Reset file input
                event.target.value = '';
                
            } catch (err) {
                console.error('Upload error:', err);
                setStatus('Upload failed', 'error');
                alert('Failed to upload file: ' + err.message);
                event.target.value = '';
            }
        }

        function deleteReferenceDoc(index) {
            if (confirm(`Delete "${referenceDocuments[index].name}"?`)) {
                referenceDocuments.splice(index, 1);
                renderReferenceDocsList();
                setStatus('Reference document deleted', 'success');
            }
        }

        function saveSession() {
            const name = document.getElementById('session-name-input').value.trim();
            if (!name) {
                alert('Please enter a session name.');
                return;
            }
            
            if (messages.length === 0) {
                alert('No messages to save.');
                return;
            }
            
            const sessions = getSessions();
            sessions[name] = {
                date: new Date().toISOString(),
                messages: messages,
                character_sheet: characterSheet,  // Include for persistence
                reference_documents: referenceDocuments  // Include reference docs
            };
            localStorage.setItem('nexus_sessions', JSON.stringify(sessions));
            
            document.getElementById('session-name-input').value = '';
            showSessions();
            setStatus(`Saved: ${name}`, 'success');
        }

        function loadSession(name) {
            const sessions = getSessions();
            if (sessions[name]) {
                messages = sessions[name].messages;
                characterSheet = sessions[name].character_sheet || '';
                referenceDocuments = sessions[name].reference_documents || [];
                renderMessages();
                closeSessions();
                setStatus(`Loaded: ${name}`, 'success');
            }
        }

        function deleteSession(name) {
            if (confirm(`Delete "${name}"?`)) {
                const sessions = getSessions();
                delete sessions[name];
                localStorage.setItem('nexus_sessions', JSON.stringify(sessions));
                showSessions();
            }
        }

        // Load from file (desktop JSON format)
        function loadFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    if (data.messages && Array.isArray(data.messages)) {
                        messages = data.messages;
                        // Load character sheet if present (cross-device sync)
                        characterSheet = data.character_sheet || '';
                        // Load reference documents if present
                        referenceDocuments = data.reference_documents || [];
                        
                        // Extract story name from filename (remove timestamp and extension)
                        let storyName = file.name.replace('.json', '');
                        // Remove _archive_TIMESTAMP or _TIMESTAMP patterns
                        storyName = storyName.replace(/_archive_\d{8}_\d{6}$/, '');
                        storyName = storyName.replace(/_\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}$/, '');
                        storyName = storyName.replace(/_\d{8}_\d{6}$/, '');
                        
                        currentStoryName = storyName;
                        localStorage.setItem('nexus_story_name', storyName);
                        document.getElementById('session-name-input').value = storyName;
                        
                        renderMessages();
                        closeSessions();
                        const hasSheet = characterSheet ? ' (with character sheet)' : '';
                        const hasRefs = referenceDocuments.length > 0 ? ` + ${referenceDocuments.length} ref doc(s)` : '';
                        setStatus(`Loaded: ${storyName}${hasSheet}${hasRefs}`, 'success');
                    } else {
                        throw new Error('Invalid session format');
                    }
                } catch (err) {
                    alert('Failed to load file: ' + err.message);
                }
            };
            input.click();
        }

        // Save to file (desktop JSON format)
        function saveToFile() {
            if (messages.length === 0) {
                alert('No messages to save.');
                return;
            }
            
            // Get name from input, or use current story name, or default to 'session'
            let baseName = document.getElementById('session-name-input').value.trim();
            if (!baseName) {
                baseName = currentStoryName || 'session';
            }
            
            // Persist the story name
            currentStoryName = baseName;
            localStorage.setItem('nexus_story_name', baseName);
            document.getElementById('session-name-input').value = baseName;
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `${baseName}_${timestamp}`;
            
            setStatus('Preparing download...', 'success');
            
            const data = {
                version: "1.0",
                created: new Date().toISOString(),
                provider: getProvider(),
                model: getModel(),
                temperature: getTemperature(),
                messages: messages,
                character_sheet: characterSheet,  // Include for cross-device sync
                reference_documents: referenceDocuments  // Include reference docs
            };
            
            try {
                // Use setTimeout to avoid blocking the UI
                setTimeout(() => {
                    try {
                        setStatus('Creating file...', 'success');
                        const jsonString = JSON.stringify(data, null, 2);
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${filename}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                        
                        setStatus(`Downloaded: ${filename}.json`, 'success');
                    } catch (err) {
                        console.error('Download error:', err);
                        setStatus(`Download failed: ${err.message}`, 'error');
                        alert(`Download failed: ${err.message}\n\nTry using Archive & Trim to reduce session size.`);
                    }
                }, 100);
            } catch (err) {
                console.error('Save preparation error:', err);
                setStatus(`Save failed: ${err.message}`, 'error');
                alert(`Save failed: ${err.message}`);
            }
        }

        // Archive full conversation, summarize to character sheet, trim to recent messages
        async function archiveAndTrim() {
            if (messages.length < 15) {
                alert('Not enough messages to archive. Need at least 15 messages.');
                return;
            }
            
            const provider = getProvider();
            const apiKey = provider === 'anthropic' ? getApiKey() : getGoogleApiKey();
            
            if (!apiKey) {
                alert('API key required for Archive & Trim (needs to generate summary).');
                return;
            }
            
            // Ask for summary quality
            const useDeep = confirm('Summary Quality:\n\nOK = Deep (Sonnet - better continuity, recommended)\nCancel = Quick (Haiku - faster, cheaper)');
            const summaryModel = useDeep ? 'claude-sonnet-4-5-20250929' : 'claude-haiku-4-5-20251001';
            
            if (!confirm('This will:\\n1. Save full archive to a file\\n2. Generate a consolidated continuity summary\\n3. Smart-trim chat to a natural scene break\\n\\nContinue?')) {
                return;
            }
            
            // Get name from input, or use current story name, or default to 'session'
            let baseName = document.getElementById('session-name-input').value.trim();
            if (!baseName) {
                baseName = currentStoryName || 'session';
            }
            
            // Persist the story name
            currentStoryName = baseName;
            localStorage.setItem('nexus_story_name', baseName);
            document.getElementById('session-name-input').value = baseName;
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const archiveFilename = `${baseName}_archive_${timestamp}.json`;
            
            // 1. Prepare archive data
            const archiveData = {
                version: "1.0",
                created: new Date().toISOString(),
                type: "archive",
                provider: getProvider(),
                model: getModel(),
                temperature: getTemperature(),
                messages: messages,
                character_sheet: characterSheet,
                reference_documents: referenceDocuments
            };
            
            const archiveJson = JSON.stringify(archiveData, null, 2);
            const archiveBlob = new Blob([archiveJson], { type: 'application/json' });
            
            // Try to save the archive file
            let archiveSaved = false;
            
            // Method 1: Try Web Share API (works well on mobile)
            if (navigator.canShare && navigator.canShare({ files: [new File([archiveBlob], archiveFilename, { type: 'application/json' })] })) {
                try {
                    const file = new File([archiveBlob], archiveFilename, { type: 'application/json' });
                    await navigator.share({
                        files: [file],
                        title: 'Nexus Archive',
                        text: `Archive: ${archiveFilename}`
                    });
                    archiveSaved = true;
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.log('Share failed, trying download:', err);
                    } else {
                        // User cancelled share
                        if (!confirm('Archive share was cancelled. Continue anyway without saving archive?')) {
                            return;
                        }
                        archiveSaved = true; // User chose to continue
                    }
                }
            }
            
            // Method 2: Traditional download (fallback)
            if (!archiveSaved) {
                const archiveUrl = URL.createObjectURL(archiveBlob);
                const archiveLink = document.createElement('a');
                archiveLink.href = archiveUrl;
                archiveLink.download = archiveFilename;
                document.body.appendChild(archiveLink);
                archiveLink.click();
                document.body.removeChild(archiveLink);
                URL.revokeObjectURL(archiveUrl);
                
                // Give user time to see the download, then confirm
                await new Promise(resolve => setTimeout(resolve, 500));
                if (!confirm(`Archive "${archiveFilename}" should be downloading.\\n\\nClick OK to continue with summary generation, or Cancel to stop.`)) {
                    return;
                }
            }
            
            setStatus('Archive saved, generating summary...', '');
            closeSessions();
            
            // Smart trim: find natural scene break near 10 messages from end
            const targetKeep = 10;
            const trimIndex = findNaturalTrimPoint(targetKeep);
            const messagesToTrim = messages.slice(0, trimIndex);
            const messagesToKeep = messages.slice(trimIndex);
            
            // Build reference doc context
            let refDocContext = '';
            if (referenceDocuments.length > 0) {
                refDocContext = '\\nREFERENCE DOCUMENTS IN USE:\\n';
                referenceDocuments.forEach(doc => {
                    refDocContext += `- ${doc.name} (${doc.content.length} chars)\\n`;
                });
            }
            
            // 2. Generate ROLLING continuity summary using AI
            try {
                let summaryPrompt = `You are the Continuity Director for a high-fidelity roleplay campaign.
Your goal is to freeze-frame the story so the next writer can pick up the EXACT facts and the EXACT feeling.

CRITICAL FAILURE POINTS TO AVOID:
1. Do not lose "Hard Data" (Classes, Session Numbers, Dates, Skill Values, Character Tier). These must be precise.
2. Do not lose "Soft Data" (Micro-expressions, tension, smells, thematic threads).
3. Do not summarize into generic RPG prose. Use the novelist's voice established in the text.
4. If existing data conflicts with session content, UPDATE to reflect the current state. Do not preserve outdated information.

YOUR TASK: Generate a SINGLE CONSOLIDATED character sheet that MERGES the existing data with the new session content.
Do NOT simply append ‚Äî integrate, update, and resolve conflicts. The result should be ONE coherent document, not a stack of session updates.

EXISTING CHARACTER SHEET:
${characterSheet || 'No existing data ‚Äî this is the first archive.'}
${refDocContext}

SESSION CONTENT TO INTEGRATE:
${messagesToTrim.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\\n\\n')}

---

GENERATE A SINGLE CONSOLIDATED CHARACTER SHEET USING THIS EXACT FORMAT:

# CHARACTER SHEET ‚Äî [Character Name] | Updated ${new Date().toLocaleDateString()}

## 1. THE NARRATIVE LENS (The "Vibe")
* **Narrative Voice:** [E.g. "Introspective, sensory-heavy. Sentences are architectural."]
* **Current Atmospheric Tension:** [E.g. "Safe but fragile. The quiet intimacy of a Saturday morning."]
* **Pacing:** [E.g. "Glacial, savory, focused on micro-moments."]
* **Active Thematic Threads:** [Themes that have emerged organically ‚Äî e.g. "Freedom vs. Belonging", "Cost of Power"]
* **Active Dramatic Questions:** [E.g. "Can the PC escape the Undercity without becoming what they hate?"]

## 2. TECHNICAL CONTINUITY (Hard Facts)
* **Current Date/Time in Story:** [e.g. Saturday, August 24th, 10:00 AM]
* **Campaign Status:** [e.g. Session 8 completed. Session 9 upcoming. Origin Arc complete / in progress.]
* **Character Tier:** [Tier 1-4, with current skill budget status]
* **Active Character Specs:**
    * **PC:** [Name, Class, Key Stats ‚Äî ALL current skill values]
    * **NPCs:** [Name, Class/Role (BE SPECIFIC - e.g. "Archfey Warlock", NOT just "caster")]
* **Inventory/Resources:** [Key items held, money, spell slots status]

## 3. THE SENSORY SNAPSHOT (The "Now")
* **Location:** [Exact room, lighting, smells. E.g. "Kitchen, smell of chives and coffee."]
* **Physical State:** [Clothing, posture. E.g. "She is wearing his Star Wars shirt and mismatched socks."]
* **The Cut:** [Exactly where the scene ended. E.g. "She just walked out the door."]

## 4. ACTIVE MICRO-DYNAMICS (The Subtext)
*For each key NPC, describe the internal state, not just external actions.*
* **[NPC Name]:** [Relationship Status]
    * *Tension Axis:* [E.g. "Loyalty ‚Üî Self-Preservation, currently 70% Loyalty"]
    * *Internal State:* [What are they feeling but not saying?]
    * *Secret:* [What the PC doesn't know yet, if anything remains hidden]
    * *Dialogue Fingerprint:* [Brief note on speech patterns]
    * *Recent Anchor:* [A specific shared moment.]
    * *Pending Tension:* [What is unresolved?]

## 5. GOLDEN MOMENTS (Style Anchors)
*2-4 direct quotes from the session that capture the prose voice and emotional tone.*
* [Quote 1]
* [Quote 2]

## 6. CAUSAL CHAIN (How We Got Here)
*The key decisions and consequences that shaped the current state.*
* [Key event/choice] ‚Üí led to ‚Üí [consequence still active]
* [PC decision at critical moment] ‚Üí resulted in ‚Üí [current situation]
* [NPC action] ‚Üí because ‚Üí [motivation] ‚Üí which means ‚Üí [future implication]

## 7. OPEN LOOPS
* **Immediate:** [Next 10 minutes in story time]
* **Short Term:** [Next session/arc]
* **Long Game:** [Campaign-level goals and unresolved arcs]

## 8. CAMPAIGN CHRONICLE (Append-only timeline)
*Brief, factual timeline of major events across ALL sessions. One line per event. Never delete entries ‚Äî only add new ones.*
[Preserve ALL existing chronicle entries, then add new ones from this session]
* [Date/Session]: [Event summary in one sentence]
`;

                let summary = '';
                
                if (provider === 'anthropic') {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: summaryModel,
                            max_tokens: 4096,
                            temperature: 0.3,
                            messages: [{ role: 'user', content: summaryPrompt }]
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        const errorMsg = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;
                        throw new Error(`API Error: ${errorMsg}`);
                    }
                    const data = await response.json();
                    summary = data.content[0].text;
                } else {
                    // Google AI
                    const googleSummaryModel = useDeep ? 'gemini-2.5-flash' : 'gemini-2.0-flash';
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${googleSummaryModel}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: summaryPrompt }] }],
                            generationConfig: { temperature: 0.3, maxOutputTokens: 4096 }
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        const errorMsg = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;
                        throw new Error(`API Error: ${errorMsg}`);
                    }
                    const data = await response.json();
                    
                    if (data.candidates?.[0]?.finishReason === 'SAFETY' || data.promptFeedback?.blockReason) {
                        throw new Error('Content blocked by safety filters. Try with a different session.');
                    }
                    if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                        throw new Error('No summary generated. API returned: ' + JSON.stringify(data).substring(0, 200));
                    }
                    
                    summary = data.candidates[0].content.parts[0].text;
                }
                
                // 3. ROLLING SUMMARY: Replace entire character sheet (not append)
                characterSheet = summary;
                
                // 4. Smart trim
                messages = messagesToKeep;
                renderMessages();
                
                setStatus('Archive & Trim complete!', 'success');
                alert(`Done!\\n\\n‚úì Full archive saved to file\\n‚úì Character sheet CONSOLIDATED (rolling summary)\\n‚úì Chat smart-trimmed to ${messagesToKeep.length} messages\\n\\nRemember to Download your current session to save the updated character sheet.`);
                
            } catch (err) {
                console.error(err);
                setStatus('Summary generation failed', 'error');
                alert('Archive saved but summary generation failed: ' + err.message + '\\n\\nChat was NOT trimmed.');
            }
        }
        
        function findNaturalTrimPoint(targetKeep) {
            const total = messages.length;
            const targetIndex = total - targetKeep;
            const searchStart = Math.max(0, targetIndex - 3);
            const searchEnd = Math.min(total, targetIndex + 3);
            
            const breakIndicators = [
                'what do you do', 'what would you like to do', 'what calls to you',
                'how do you respond', "what's your move", 'where do you go',
                'since last time', 'time passes', 'the dust settles',
                'your origin is written', 'the world opens',
                'unresolved threads', 'what speaks to you',
                'how much time passes', 'continue immediately'
            ];
            
            let bestIndex = targetIndex;
            
            for (let i = searchStart; i < searchEnd; i++) {
                if (i < total && messages[i].role === 'assistant') {
                    const contentLower = messages[i].content.toLowerCase().slice(-200);
                    for (const indicator of breakIndicators) {
                        if (contentLower.includes(indicator)) {
                            bestIndex = i + 1;
                            break;
                        }
                    }
                }
            }
            
            return Math.max(2, Math.min(bestIndex, total - 2));
        }

        function newSession() {
            if (messages.length > 0 && !confirm('Start a new session? Unsaved progress will be lost.')) {
                return;
            }
            messages = [];
            
            // Ask if user wants to keep character sheet for the new session
            if (characterSheet) {
                if (!confirm('Keep character sheet for the new session?\n\n(OK = Keep for continuation, Cancel = Clear for fresh start)')) {
                    characterSheet = '';
                }
            }
            
            // Ask if user wants to keep reference docs for the new session
            if (referenceDocuments.length > 0) {
                if (!confirm(`Keep ${referenceDocuments.length} reference document(s) for the new session?`)) {
                    referenceDocuments = [];
                }
            }
            
            currentStoryName = '';  // Clear story name
            localStorage.removeItem('nexus_story_name');
            renderMessages();
            setStatus('New session started');
        }

        // ============================================================
        // CHAT
        // ============================================================
        function renderMessages() {
            const container = document.getElementById('chat-container');
            
            if (messages.length === 0) {
                container.innerHTML = `
                    <div class="welcome">
                        <h2>The Nexus Awaits</h2>
                        <p>Your framework is loaded and ready.<br>Type "Begin" to start a new session.</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = messages.map(msg => `
                <div class="message ${msg.role}">
                    <div class="message-role">${msg.role === 'user' ? 'You' : 'The Nexus'}</div>
                    <div class="message-content">${escapeHtml(msg.content)}</div>
                </div>
            `).join('');
            
            scrollToBottom();
        }

        function addMessage(role, content) {
            const container = document.getElementById('chat-container');
            
            // Remove welcome if present
            const welcome = container.querySelector('.welcome');
            if (welcome) welcome.remove();
            
            const div = document.createElement('div');
            div.className = `message ${role}`;
            div.innerHTML = `
                <div class="message-role">${role === 'user' ? 'You' : 'The Nexus'}</div>
                <div class="message-content">${escapeHtml(content)}</div>
            `;
            container.appendChild(div);
            scrollToBottom();
            
            return div;
        }

        function updateLastMessage(content) {
            const messages = document.querySelectorAll('.message.assistant');
            const last = messages[messages.length - 1];
            if (last) {
                last.querySelector('.message-content').textContent = content;
                scrollToBottom();
            }
        }

        function scrollToBottom() {
            const container = document.getElementById('chat-container');
            container.scrollTop = container.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function setStatus(text, type = '') {
            const status = document.getElementById('status');
            status.textContent = text;
            status.className = 'status ' + type;
        }

        // ============================================================
        // API
        // ============================================================
        async function sendMessage() {
            const input = document.getElementById('message-input');
            const content = input.value.trim();
            
            if (!content || isGenerating) return;
            
            const provider = getProvider();
            const apiKey = provider === 'anthropic' ? getApiKey() : getGoogleApiKey();
            
            if (!apiKey) {
                showSettings();
                alert(`Please enter your ${provider === 'anthropic' ? 'Anthropic' : 'Google AI'} API key first.`);
                return;
            }
            
            // Add user message
            messages.push({ role: 'user', content });
            addMessage('user', content);
            input.value = '';
            input.style.height = 'auto';
            
            // Start generating
            isGenerating = true;
            document.getElementById('send-btn').disabled = true;
            document.getElementById('send-btn').textContent = 'Stop';
            document.getElementById('send-btn').onclick = stopGeneration;
            setStatus('Generating...');
            
            // Add placeholder for assistant message
            addMessage('assistant', '‚ñå');
            
            abortController = new AbortController();
            
            try {
                // Build full system prompt
                let systemPrompt = NEXUS_FRAMEWORK;
                if (characterSheet) {
                    systemPrompt += '\n\n' + '='.repeat(60) + '\n';
                    systemPrompt += 'PERSISTENT CHARACTER SHEET & CONTINUITY LOG\n';
                    systemPrompt += '(Reference this for character details, relationships, and past events)\n';
                    systemPrompt += '='.repeat(60) + '\n\n';
                    systemPrompt += characterSheet;
                }
                if (referenceDocuments.length > 0) {
                    systemPrompt += '\n\n' + '='.repeat(60) + '\n';
                    systemPrompt += 'REFERENCE DOCUMENTS\n';
                    systemPrompt += '(Player-provided materials for this campaign - rules, playbooks, maps, etc.)\n';
                    systemPrompt += '='.repeat(60) + '\n\n';
                    referenceDocuments.forEach(doc => {
                        systemPrompt += `--- ${doc.name} ---\n\n${doc.content}\n\n`;
                    });
                }
                
                let fullContent = '';
                
                if (provider === 'anthropic') {
                    // Anthropic Claude API
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: getModel(),
                            max_tokens: 12288,
                            temperature: getTemperature(),
                            system: systemPrompt,
                            messages: messages.filter(m => m.role !== 'system'),
                            stream: true
                        }),
                        signal: abortController.signal
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error?.message || `API Error: ${response.status}`);
                    }
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.type === 'content_block_delta' && parsed.delta?.text) {
                                        fullContent += parsed.delta.text;
                                        updateLastMessage(fullContent + '‚ñå');
                                    }
                                } catch (e) {
                                    // Skip parse errors for incomplete chunks
                                }
                            }
                        }
                    }
                } else if (provider === 'google') {
                    // Google Gemini API
                    // Build conversation history for Gemini
                    const geminiContents = [];
                    
                    // Add system instruction as first user message (Gemini style)
                    // Then build conversation
                    for (const msg of messages.slice(0, -1)) {
                        geminiContents.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    // Last user message
                    geminiContents.push({
                        role: 'user',
                        parts: [{ text: messages[messages.length - 1].content }]
                    });
                    
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${getModel()}:streamGenerateContent?alt=sse&key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: geminiContents,
                            systemInstruction: {
                                parts: [{ text: systemPrompt }]
                            },
                            generationConfig: {
                                temperature: Math.min(getTemperature(), 1.0),  // Google max is 1.0
                                maxOutputTokens: 12288
                            }
                        }),
                        signal: abortController.signal
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error?.message || `API Error: ${response.status}`);
                    }
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.candidates?.[0]?.content?.parts?.[0]?.text) {
                                        fullContent += parsed.candidates[0].content.parts[0].text;
                                        updateLastMessage(fullContent + '‚ñå');
                                    }
                                } catch (e) {
                                    // Skip parse errors
                                }
                            }
                        }
                    }
                }
                
                // Finalize
                messages.push({ role: 'assistant', content: fullContent });
                updateLastMessage(fullContent);
                setStatus('Ready', 'success');
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    setStatus('Stopped', '');
                } else {
                    console.error(error);
                    setStatus(`Error: ${error.message}`, 'error');
                    // Remove the placeholder message
                    const lastMsg = document.querySelector('.message.assistant:last-child');
                    if (lastMsg && lastMsg.querySelector('.message-content').textContent === '‚ñå') {
                        lastMsg.remove();
                    }
                    // Remove the user message from history since it failed
                    messages.pop();
                }
            } finally {
                isGenerating = false;
                document.getElementById('send-btn').disabled = false;
                document.getElementById('send-btn').textContent = 'Send';
                document.getElementById('send-btn').onclick = sendMessage;
                abortController = null;
            }
        }

        function stopGeneration() {
            if (abortController) {
                abortController.abort();
            }
        }

        // ============================================================
        // INPUT HANDLING
        // ============================================================
        const input = document.getElementById('message-input');
        
        // Auto-resize textarea
        input.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 150) + 'px';
        });
        
        // Enter to send, Shift+Enter for newline
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // ============================================================
        // SCROLL HANDLER - Floating Header
        // ============================================================
        const header = document.getElementById('header');
        const chatContainer = document.getElementById('chat-container');
        
        chatContainer.addEventListener('scroll', () => {
            if (chatContainer.scrollTop > 50) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }
        });

        // ============================================================
        // INIT
        // ============================================================
        // Check for API key on load
        if (!getApiKey() && !getGoogleApiKey()) {
            setTimeout(() => {
                setStatus('Please set your API key in Settings', 'error');
            }, 500);
        }
    </script>
</body>
</html>